Tuy·ªát v·ªùi! üéâ T√¥i s·∫Ω chia **File 2** th√†nh **3 ph·∫ßn** ƒë·ªÉ d·ªÖ qu·∫£n l√Ω:

- **File 2.1**: `pipeline_chi_tiet_part1.md` - Phase 1 & 2 (Setup & Mock AI)
- **File 2.2**: `pipeline_chi_tiet_part2.md` - Phase 3 & 4 (Backend & Frontend Core)  
- **File 2.3**: `pipeline_chi_tiet_part3.md` - Phase 5 & 6 (Admin Features & Testing)

---

Gi·ªù t√¥i ti·∫øp t·ª•c **ho√†n th√†nh File 2.1** (ph·∫ßn c√≤n l·∫°i c·ªßa Phase 2), sau ƒë√≥ s·∫Ω t·∫°o File 2.2 v√† 2.3 nh√©!

---

## **TI·∫æP T·ª§C FILE 2.1 - Phase 2 (Mock AI Services)**

```markdown
## 2.2. Mock License Plate Recognition Service

| **C√¥ng vi·ªác (Task)** | **Ph√¢n t√≠ch & H∆∞·ªõng d·∫´n chi ti·∫øt** | **Code minh h·ªça** | **L∆∞u √Ω (Important Notes)** |
|----------------------|-----------------------------------|-------------------|----------------------------|
| T·∫°o mock function cho LPR (License Plate Recognition) | **2-stage process**:<br>1. Detect plate region trong vehicle crop<br>2. OCR text t·ª´ plate<br><br>**Vietnamese plate format**:<br>- Format: `XX(X)-YYYYY`<br>- Examples: `30A-12345`, `51B-67890`<br>- Validate format | ```typescript<br>// src/services/ai/mockLPR.ts<br><br>/**<br> * License Plate Recognition Result<br> */<br>export interface LPRResult {<br>  plateText: string;        // e.g., "30A-12345"<br>  confidence: number;       // 0-1<br>  boundingBox: {            // Plate location in image<br>    x: number;<br>    y: number;<br>    width: number;<br>    height: number;<br>  };<br>}<br><br>/**<br> * Mock License Plate Recognition Service<br> * <br> * Gi·∫£ l·∫≠p 2-stage LPR:<br> * 1. Plate Detection (YOLO)<br> * 2. OCR (EasyOCR/PaddleOCR)<br> */<br>export class MockLPRService {<br>  // Pool of Vietnamese license plates for mock data<br>  private readonly MOCK_PLATES = [<br>    '30A-12345', '30A-67890', '30B-11111',<br>    '51B-22222', '51C-33333', '51D-44444',<br>    '29C-55555', '29D-66666', '29E-77777',<br>    '92A-88888', '92B-99999', '92C-12121',<br>    '43F-23232', '59G-34343', '77H-45454',<br>  ];<br>  <br>  private usedPlates: Set<string> = new Set();<br>  <br>  /**<br>   * Recognize license plate from vehicle image<br>   * @param vehicleImage - Cropped vehicle image<br>   * @returns LPR result with plate text<br>   */<br>  async recognizePlate(vehicleImage: string | File): Promise<LPRResult> {<br>    // Simulate processing delay<br>    await this.simulateDelay(300, 700);<br>    <br>    // Get unique plate (or random if all used)<br>    const plateText = this.getRandomPlate();<br>    <br>    // Random confidence (high for mock)<br>    const confidence = this.randomFloat(0.90, 0.99);<br>    <br>    // Mock plate bounding box (assume plate is in lower 1/3 of vehicle image)<br>    const boundingBox = {<br>      x: this.randomInt(20, 40),<br>      y: this.randomInt(60, 80), // % of image height<br>      width: this.randomInt(40, 60),<br>      height: this.randomInt(10, 15),<br>    };<br>    <br>    console.log(`üî¢ Mock LPR: ${plateText} (confidence: ${confidence.toFixed(2)})`);<br>    <br>    return {<br>      plateText,<br>      confidence,<br>      boundingBox,<br>    };<br>  }<br>  <br>  /**<br>   * Batch recognize plates from multiple vehicle crops<br>   * @param vehicleImages - Array of vehicle images<br>   * @returns Array of LPR results<br>   */<br>  async recognizePlates(vehicleImages: Array<string | File>): Promise<LPRResult[]> {<br>    const results: LPRResult[] = [];<br>    <br>    for (const image of vehicleImages) {<br>      const result = await this.recognizePlate(image);<br>      results.push(result);<br>    }<br>    <br>    return results;<br>  }<br>  <br>  /**<br>   * Validate Vietnamese license plate format<br>   * @param plate - Plate text to validate<br>   * @returns true if valid format<br>   */<br>  validatePlateFormat(plate: string): boolean {<br>    // Vietnamese format: XX(X)-YYYYY<br>    // XX: 2 digits (province code)<br>    // (X): Optional letter<br>    // YYYYY: 4-5 digits<br>    const regex = /^[0-9]{2}[A-Z]-[0-9]{4,5}$/;<br>    return regex.test(plate);<br>  }<br>  <br>  /**<br>   * Extract province code from plate<br>   * @param plate - License plate text<br>   * @returns Province code (e.g., "30" for Hanoi)<br>   */<br>  extractProvinceCode(plate: string): string | null {<br>    const match = plate.match(/^([0-9]{2})[A-Z]-[0-9]{4,5}$/);<br>    return match ? match[1] : null;<br>  }<br>  <br>  /**<br>   * Get province name from code (simplified)<br>   */<br>  getProvinceName(code: string): string {<br>    const provinces: Record<string, string> = {<br>      '30': 'H√† N·ªôi',<br>      '51': 'TP. H·ªì Ch√≠ Minh',<br>      '29': 'H√† Nam',<br>      '92': 'C·∫ßn Th∆°',<br>      '43': 'ƒê√† N·∫µng',<br>      '59': 'B√† R·ªãa - V≈©ng T√†u',<br>      '77': 'B·∫Øc K·∫°n',<br>    };<br>    return provinces[code] || 'Unknown';<br>  }<br>  <br>  // ========== UTILITY METHODS ==========<br>  <br>  private getRandomPlate(): string {<br>    // Try to get unused plate<br>    const availablePlates = this.MOCK_PLATES.filter(<br>      p => !this.usedPlates.has(p)<br>    );<br>    <br>    if (availablePlates.length > 0) {<br>      const plate = availablePlates[Math.floor(Math.random() * availablePlates.length)];<br>      this.usedPlates.add(plate);<br>      return plate;<br>    }<br>    <br>    // All plates used, return random<br>    return this.MOCK_PLATES[Math.floor(Math.random() * this.MOCK_PLATES.length)];<br>  }<br>  <br>  private randomInt(min: number, max: number): number {<br>    return Math.floor(Math.random() * (max - min + 1)) + min;<br>  }<br>  <br>  private randomFloat(min: number, max: number): number {<br>    return Math.random() * (max - min) + min;<br>  }<br>  <br>  private async simulateDelay(minMs: number, maxMs: number): Promise<void> {<br>    const delay = this.randomInt(minMs, maxMs);<br>    return new Promise(resolve => setTimeout(resolve, delay));<br>  }<br>  <br>  /**<br>   * Reset used plates pool<br>   */<br>  reset() {<br>    this.usedPlates.clear();<br>  }<br>}<br><br>// Export singleton<br>export const mockLPR = new MockLPRService();<br>``` | **üöó Vietnamese Plate Format**:<br>‚Ä¢ Province: 2 digits (e.g., 30 = Hanoi)<br>‚Ä¢ Letter: 1 letter (A-Z)<br>‚Ä¢ Number: 4-5 digits<br>‚Ä¢ Separator: Dash (-)<br><br>**Example plates**:<br>‚Ä¢ 30A-12345 (Hanoi)<br>‚Ä¢ 51B-67890 (HCMC)<br>‚Ä¢ 29C-11111 (Ha Nam)<br><br>**üîÑ Real Implementation**:<br>Replace v·ªõi:<br>‚Ä¢ YOLOv8 fine-tuned for plates<br>‚Ä¢ EasyOCR or PaddleOCR<br>‚Ä¢ Post-processing for accuracy<br><br>**‚úÖ Validation Important**:<br>```typescript<br>if (!mockLPR.validatePlateFormat(plate)) {<br>  throw new Error('Invalid plate format');<br>}<br>```<br><br>**üéØ Usage Example**:<br>```typescript<br>const result = await mockLPR.recognizePlate(vehicleCrop);<br>console.log(result.plateText); // "30A-12345"<br>console.log(result.confidence); // 0.95<br>``` |

## 2.3. Mock Object Tracking Service

| **C√¥ng vi·ªác (Task)** | **Ph√¢n t√≠ch & H∆∞·ªõng d·∫´n chi ti·∫øt** | **Code minh h·ªça** | **L∆∞u √Ω (Important Notes)** |
|----------------------|-----------------------------------|-------------------|----------------------------|
| T·∫°o mock tracking ƒë·ªÉ g√°n Tracking ID | **Object Tracking purpose**:<br>- G√°n unique ID cho m·ªói xe<br>- Theo d√µi trajectory (qu·ªπ ƒë·∫°o)<br>- X√°c ƒë·ªãnh khi xe v√†o/ra parking space<br>- Maintain identity across frames<br><br>**Real tracking**: DeepSORT/ByteTrack | ```typescript<br>// src/services/ai/mockTracking.ts<br><br>/**<br> * Tracking Info<br> */<br>export interface TrackingInfo {<br>  trackingId: string;       // e.g., "TRK_001"<br>  vehicleId: string | null; // Link to registered vehicle<br>  licensePlate: string;     // From LPR<br>  trajectory: Array<{       // Movement history<br>    x: number;<br>    y: number;<br>    timestamp: number;<br>  }>;<br>  status: 'moving' | 'parked' | 'leaving';<br>  parkingSpaceId: string | null;<br>  confidence: number;       // Tracking confidence<br>  lastSeen: number;         // Timestamp<br>}<br><br>/**<br> * Mock Object Tracking Service<br> * <br> * Gi·∫£ l·∫≠p DeepSORT/ByteTrack tracking<br> * G√°n tracking ID v√† maintain identity<br> */<br>export class MockTrackingService {<br>  private trackingCounter = 1;<br>  private activeTracks: Map<string, TrackingInfo> = new Map();<br>  <br>  /**<br>   * Update tracking v·ªõi detections m·ªõi<br>   * @param detections - Detection results from current frame<br>   * @param timestamp - Current timestamp<br>   * @returns Updated tracking info<br>   */<br>  async updateTracking(<br>    detections: Array<{<br>      bbox: {x: number; y: number; width: number; height: number};<br>      licensePlate?: string;<br>    }>,<br>    timestamp: number = Date.now()<br>  ): Promise<TrackingInfo[]> {<br>    await this.simulateDelay(50, 150);<br>    <br>    const updatedTracks: TrackingInfo[] = [];<br>    <br>    for (const detection of detections) {<br>      // Calculate center position<br>      const centerX = detection.bbox.x + detection.bbox.width / 2;<br>      const centerY = detection.bbox.y + detection.bbox.height / 2;<br>      <br>      // Try to match with existing track (simplified)<br>      let track = this.findNearestTrack(centerX, centerY);<br>      <br>      if (!track) {<br>        // Create new track<br>        const trackingId = this.generateTrackingId();<br>        track = {<br>          trackingId,<br>          vehicleId: null,<br>          licensePlate: detection.licensePlate || 'UNKNOWN',<br>          trajectory: [{x: centerX, y: centerY, timestamp}],<br>          status: 'moving',<br>          parkingSpaceId: null,<br>          confidence: 0.95,<br>          lastSeen: timestamp,<br>        };<br>        this.activeTracks.set(trackingId, track);<br>        console.log(`üÜï New track: ${trackingId}`);<br>      } else {<br>        // Update existing track<br>        track.trajectory.push({x: centerX, y: centerY, timestamp});<br>        track.lastSeen = timestamp;<br>        <br>        // Update status based on movement<br>        track.status = this.determineStatus(track.trajectory);<br>        <br>        console.log(`üîÑ Updated track: ${track.trackingId} (${track.status})`);<br>      }<br>      <br>      updatedTracks.push(track);<br>    }<br>    <br>    // Remove old tracks (not seen for > 5 seconds)<br>    this.removeOldTracks(timestamp);<br>    <br>    return updatedTracks;<br>  }<br>  <br>  /**<br>   * Assign vehicle ID to tracking<br>   * @param trackingId - Tracking ID<br>   * @param vehicleId - Registered vehicle ID<br>   */<br>  assignVehicleId(trackingId: string, vehicleId: string): void {<br>    const track = this.activeTracks.get(trackingId);<br>    if (track) {<br>      track.vehicleId = vehicleId;<br>      console.log(`üîó Linked ${trackingId} -> Vehicle ${vehicleId}`);<br>    }<br>  }<br>  <br>  /**<br>   * Assign parking space to tracking<br>   * @param trackingId - Tracking ID<br>   * @param spaceId - Parking space ID<br>   */<br>  assignParkingSpace(trackingId: string, spaceId: string): void {<br>    const track = this.activeTracks.get(trackingId);<br>    if (track) {<br>      track.parkingSpaceId = spaceId;<br>      track.status = 'parked';<br>      console.log(`üÖøÔ∏è ${trackingId} parked at ${spaceId}`);<br>    }<br>  }<br>  <br>  /**<br>   * Get all active tracks<br>   */<br>  getActiveTracks(): TrackingInfo[] {<br>    return Array.from(this.activeTracks.values());<br>  }<br>  <br>  /**<br>   * Get track by ID<br>   */<br>  getTrack(trackingId: string): TrackingInfo | undefined {<br>    return this.activeTracks.get(trackingId);<br>  }<br>  <br>  // ========== PRIVATE METHODS ==========<br>  <br>  private generateTrackingId(): string {<br>    const id = `TRK_${String(this.trackingCounter).padStart(3, '0')}`;<br>    this.trackingCounter++;<br>    return id;<br>  }<br>  <br>  private findNearestTrack(x: number, y: number): TrackingInfo | null {<br>    let nearestTrack: TrackingInfo | null = null;<br>    let minDistance = Infinity;<br>    const DISTANCE_THRESHOLD = 100; // pixels<br>    <br>    for (const track of this.activeTracks.values()) {<br>      if (track.trajectory.length === 0) continue;<br>      <br>      const lastPos = track.trajectory[track.trajectory.length - 1];<br>      const distance = Math.sqrt(<br>        Math.pow(x - lastPos.x, 2) + Math.pow(y - lastPos.y, 2)<br>      );<br>      <br>      if (distance < minDistance && distance < DISTANCE_THRESHOLD) {<br>        minDistance = distance;<br>        nearestTrack = track;<br>      }<br>    }<br>    <br>    return nearestTrack;<br>  }<br>  <br>  private determineStatus(trajectory: TrackingInfo['trajectory']): TrackingInfo['status'] {<br>    if (trajectory.length < 5) return 'moving';<br>    <br>    // Get last 5 positions<br>    const recent = trajectory.slice(-5);<br>    <br>    // Calculate average movement<br>    let totalMovement = 0;<br>    for (let i = 1; i < recent.length; i++) {<br>      const dx = recent[i].x - recent[i-1].x;<br>      const dy = recent[i].y - recent[i-1].y;<br>      totalMovement += Math.sqrt(dx * dx + dy * dy);<br>    }<br>    <br>    const avgMovement = totalMovement / (recent.length - 1);<br>    <br>    // Threshold: < 5 pixels = parked<br>    if (avgMovement < 5) return 'parked';<br>    return 'moving';<br>  }<br>  <br>  private removeOldTracks(currentTime: number): void {<br>    const TIMEOUT = 5000; // 5 seconds<br>    <br>    for (const [trackingId, track] of this.activeTracks.entries()) {<br>      if (currentTime - track.lastSeen > TIMEOUT) {<br>        this.activeTracks.delete(trackingId);<br>        console.log(`‚ùå Removed old track: ${trackingId}`);<br>      }<br>    }<br>  }<br>  <br>  private async simulateDelay(minMs: number, maxMs: number): Promise<void> {<br>    const delay = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;<br>    return new Promise(resolve => setTimeout(resolve, delay));<br>  }<br>  <br>  /**<br>   * Reset all tracking<br>   */<br>  reset(): void {<br>    this.activeTracks.clear();<br>    this.trackingCounter = 1;<br>  }<br>}<br><br>// Export singleton<br>export const mockTracking = new MockTrackingService();<br>``` | **üéØ Tracking Logic**:<br>1. Match detection v·ªõi existing tracks<br>2. N·∫øu match: Update trajectory<br>3. N·∫øu kh√¥ng: Create new track<br>4. Remove tracks kh√¥ng seen > 5s<br><br>**üìç Status Determination**:<br>‚Ä¢ **Moving**: Avg movement > 5px<br>‚Ä¢ **Parked**: Avg movement < 5px<br>‚Ä¢ **Leaving**: Moving sau khi parked<br><br>**üîó Linking**:<br>```typescript<br>// Link tracking to registered vehicle<br>mockTracking.assignVehicleId(<br>  'TRK_001',<br>  'ABC1234'<br>);<br><br>// Link to parking space<br>mockTracking.assignParkingSpace(<br>  'TRK_001',<br>  'A2'<br>);<br>```<br><br>**Real Tracking**:<br>‚Ä¢ DeepSORT: Appearance + Motion<br>‚Ä¢ ByteTrack: Motion only (faster)<br>‚Ä¢ Kalman Filter: Predict next position<br>‚Ä¢ Hungarian Algorithm: Optimal matching |

## 2.4. Mock Anomaly Detection Service

| **C√¥ng vi·ªác (Task)** | **Ph√¢n t√≠ch & H∆∞·ªõng d·∫´n chi ti·∫øt** | **Code minh h·ªça** | **L∆∞u √Ω (Important Notes)** |
|----------------------|-----------------------------------|-------------------|----------------------------|
| T·∫°o rule-based anomaly detection | **Anomaly types**:<br>1. Wrong parking (ƒë·ªó sai v·ªã tr√≠)<br>2. Unregistered vehicle<br>3. Overstay (ƒë·ªó qu√° l√¢u)<br>4. Incident (s·ª± c·ªë)<br>5. Overload (b√£i qu√° t·∫£i)<br><br>**Logic**: Rule-based checks | ```typescript<br>// src/services/ai/mockAnomalyDetection.ts<br>import type { <br>  Alert, <br>  AlertType, <br>  AlertSeverity <br>} from '@/types/firestore.types';<br>import { Timestamp } from 'firebase/firestore';<br><br>/**<br> * Parking Space Info (for anomaly detection)<br> */<br>interface ParkingSpaceInfo {<br>  spaceId: string;<br>  occupied: boolean;<br>  polygon: Array<{x: number; y: number}>;<br>}<br><br>/**<br> * Vehicle Info (for anomaly detection)<br> */<br>interface VehicleInfo {<br>  vehicleId: string;<br>  licensePlate: string;<br>  position: {x: number; y: number};<br>  checkInTime: number; // timestamp<br>  registered: boolean;<br>}<br><br>/**<br> * Mock Anomaly Detection Service<br> * <br> * Rule-based logic ƒë·ªÉ ph√°t hi·ªán b·∫•t th∆∞·ªùng<br> */<br>export class MockAnomalyDetectionService {<br>  private alertCounter = 1;<br>  <br>  // Configuration<br>  private readonly MAX_STAY_HOURS = 8;<br>  private readonly OVERLOAD_THRESHOLD = 0.95; // 95%<br>  private readonly WRONG_PARKING_IOU_THRESHOLD = 0.5;<br>  <br>  /**<br>   * Detect all anomalies in current state<br>   * @param vehicles - Current vehicles<br>   * @param parkingSpaces - All parking spaces<br>   * @returns Array of detected anomalies<br>   */<br>  async detectAnomalies(<br>    vehicles: VehicleInfo[],<br>    parkingSpaces: ParkingSpaceInfo[]<br>  ): Promise<Partial<Alert>[]> {<br>    await this.simulateDelay(200, 500);<br>    <br>    const anomalies: Partial<Alert>[] = [];<br>    <br>    const currentTime = Date.now();<br>    <br>    // Check each vehicle<br>    for (const vehicle of vehicles) {<br>      // 1. Check if unregistered<br>      if (!vehicle.registered) {<br>        anomalies.push(this.createAlert(<br>          'unregistered',<br>          'medium',<br>          vehicle,<br>          `Xe ch∆∞a ƒëƒÉng k√Ω: ${vehicle.licensePlate}`<br>        ));<br>      }<br>      <br>      // 2. Check overstay<br>      const stayHours = (currentTime - vehicle.checkInTime) / (1000 * 60 * 60);<br>      if (stayHours > this.MAX_STAY_HOURS) {<br>        anomalies.push(this.createAlert(<br>          'overstay',<br>          'low',<br>          vehicle,<br>          `Xe ƒë·ªó qu√° ${stayHours.toFixed(1)} gi·ªù`<br>        ));<br>      }<br>      <br>      // 3. Check wrong parking (position not in any space)<br>      const isInValidSpace = this.checkVehicleInSpace(vehicle, parkingSpaces);<br>      if (!isInValidSpace) {<br>        anomalies.push(this.createAlert(<br>          'wrong_parking',<br>          'medium',<br>          vehicle,<br>          'Xe ƒë·ªó ngo√†i v·∫°ch k·∫ª'<br>        ));<br>      }<br>    }<br>    <br>    // 4. Check overload<br>    const occupiedCount = parkingSpaces.filter(s => s.occupied).length;<br>    const occupancyRate = occupiedCount / parkingSpaces.length;<br>    <br>    if (occupancyRate > this.OVERLOAD_THRESHOLD) {<br>      anomalies.push({<br>        alertId: this.generateAlertId(),<br>        type: 'overload',<br>        severity: occupancyRate > 0.98 ? 'critical' : 'high',<br>        vehicleId: null,<br>        licensePlate: null,<br>        location: 'To√†n b·ªô b√£i ƒë·ªó',<br>        description: `B√£i ƒë·ªó ƒë·∫°t ${(occupancyRate * 100).toFixed(1)}% capacity`,<br>        resolved: false,<br>        resolvedBy: null,<br>        timestamp: Timestamp.now(),<br>        resolvedAt: null,<br>      });<br>    }<br>    <br>    console.log(`‚ö†Ô∏è Detected ${anomalies.length} anomalies`);<br>    <br>    return anomalies;<br>  }<br>  <br>  /**<br>   * Check single vehicle for anomalies<br>   * @param vehicle - Vehicle to check<br>   * @param parkingSpaces - All parking spaces<br>   * @returns Alert if anomaly detected, null otherwise<br>   */<br>  async checkVehicle(<br>    vehicle: VehicleInfo,<br>    parkingSpaces: ParkingSpaceInfo[]<br>  ): Promise<Partial<Alert> | null> {<br>    const anomalies = await this.detectAnomalies([vehicle], parkingSpaces);<br>    return anomalies.length > 0 ? anomalies[0] : null;<br>  }<br>  <br>  /**<br>   * Simulate random anomaly (for testing)<br>   * @returns Random alert<br>   */<br>  generateRandomAnomaly(): Partial<Alert> {<br>    const types: AlertType[] = [<br>      'wrong_parking',<br>      'unregistered',<br>      'overstay',<br>      'incident'<br>    ];<br>    <br>    const type = types[Math.floor(Math.random() * types.length)];<br>    const severity: AlertSeverity = Math.random() > 0.5 ? 'medium' : 'low';<br>    <br>    return {<br>      alertId: this.generateAlertId(),<br>      type,<br>      severity,<br>      vehicleId: `MOCK${Math.floor(Math.random() * 1000)}`,<br>      licensePlate: `30A-${Math.floor(Math.random() * 90000) + 10000}`,<br>      location: { x: Math.random() * 1000, y: Math.random() * 1000 },<br>      description: `Mock anomaly: ${type}`,<br>      resolved: false,<br>      resolvedBy: null,<br>      timestamp: Timestamp.now(),<br>      resolvedAt: null,<br>    };<br>  }<br>  <br>  // ========== PRIVATE METHODS ==========<br>  <br>  private createAlert(<br>    type: AlertType,<br>    severity: AlertSeverity,<br>    vehicle: VehicleInfo,<br>    description: string<br>  ): Partial<Alert> {<br>    return {<br>      alertId: this.generateAlertId(),<br>      type,<br>      severity,<br>      vehicleId: vehicle.vehicleId,<br>      licensePlate: vehicle.licensePlate,<br>      location: vehicle.position,<br>      description,<br>      resolved: false,<br>      resolvedBy: null,<br>      timestamp: Timestamp.now(),<br>      resolvedAt: null,<br>    };<br>  }<br>  <br>  private generateAlertId(): string {<br>    const date = new Date();<br>    const dateStr = date.toISOString().slice(0, 10).replace(/-/g, '');<br>    const id = `ALT_${dateStr}_${String(this.alertCounter).padStart(3, '0')}`;<br>    this.alertCounter++;<br>    return id;<br>  }<br>  <br>  private checkVehicleInSpace(<br>    vehicle: VehicleInfo,<br>    parkingSpaces: ParkingSpaceInfo[]<br>  ): boolean {<br>    // Simplified: Check if vehicle position is inside any parking space polygon<br>    for (const space of parkingSpaces) {<br>      if (this.pointInPolygon(vehicle.position, space.polygon)) {<br>        return true;<br>      }<br>    }<br>    return false;<br>  }<br>  <br>  /**<br>   * Point-in-polygon algorithm (Ray casting)<br>   */<br>  private pointInPolygon(<br>    point: {x: number; y: number},<br>    polygon: Array<{x: number; y: number}><br>  ): boolean {<br>    let inside = false;<br>    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {<br>      const xi = polygon[i].x, yi = polygon[i].y;<br>      const xj = polygon[j].x, yj = polygon[j].y;<br>      <br>      const intersect = ((yi > point.y) !== (yj > point.y))<br>        && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);<br>      if (intersect) inside = !inside;<br>    }<br>    return inside;<br>  }<br>  <br>  private async simulateDelay(minMs: number, maxMs: number): Promise<void> {<br>    const delay = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;<br>    return new Promise(resolve => setTimeout(resolve, delay));<br>  }<br>  <br>  /**<br>   * Reset counter<br>   */<br>  reset(): void {<br>    this.alertCounter = 1;<br>  }<br>}<br><br>// Export singleton<br>export const mockAnomalyDetection = new MockAnomalyDetectionService();<br>``` | **üîç Anomaly Types**:<br><br>**1. Wrong Parking**:<br>‚Ä¢ Vehicle position not in any parking space<br>‚Ä¢ Check: Point-in-polygon<br><br>**2. Unregistered**:<br>‚Ä¢ License plate not in database<br>‚Ä¢ Check: Query Firestore<br><br>**3. Overstay**:<br>‚Ä¢ Stay time > MAX_STAY_HOURS<br>‚Ä¢ Check: currentTime - checkInTime<br><br>**4. Overload**:<br>‚Ä¢ Occupancy > 95%<br>‚Ä¢ Check: occupied / total<br><br>**5. Incident** (not implemented):<br>‚Ä¢ Sudden stop<br>‚Ä¢ Collision detection<br><br>**‚öôÔ∏è Configuration**:<br>```typescript<br>// Adjust thresholds<br>MAX_STAY_HOURS = 8;<br>OVERLOAD_THRESHOLD = 0.95;<br>```<br><br>**üßÆ Point-in-Polygon**:<br>‚Ä¢ Ray casting algorithm<br>‚Ä¢ O(n) complexity<br>‚Ä¢ Works for any polygon shape |

## 2.5. Integrate All Mock AI Services

| **C√¥ng vi·ªác (Task)** | **Ph√¢n t√≠ch & H∆∞·ªõng d·∫´n chi ti·∫øt** | **Code minh h·ªça** | **L∆∞u √Ω (Important Notes)** |
|----------------------|-----------------------------------|-------------------|----------------------------|
| T·∫°o unified AI service facade | **Facade pattern**:<br>- Single entry point cho t·∫•t c·∫£ AI services<br>- ƒê∆°n gi·∫£n h√≥a usage<br>- D·ªÖ replace v·ªõi real AI sau<br><br>**Workflow**:<br>1. Detect vehicles<br>2. Recognize plates<br>3. Update tracking<br>4. Detect anomalies | ```typescript<br>// src/services/ai/aiService.ts<br>import { mockObjectDetection } from './mockObjectDetection';<br>import { mockLPR } from './mockLPR';<br>import { mockTracking } from './mockTracking';<br>import { mockAnomalyDetection } from './mockAnomalyDetection';<br>import type { Alert } from '@/types/firestore.types';<br><br>/**<br> * AI Processing Result<br> */<br>export interface AIProcessingResult {<br>  detections: Array<{<br>    bbox: {x: number; y: number; width: number; height: number};<br>    class: 'car' | 'motorbike';<br>    confidence: number;<br>    licensePlate: string;<br>    trackingId: string;<br>  }>;<br>  anomalies: Partial<Alert>[];<br>  summary: {<br>    totalVehicles: number;<br>    totalAnomalies: number;<br>    processingTime: number; // ms<br>  };<br>}<br><br>/**<br> * Unified AI Service<br> * <br> * Facade cho t·∫•t c·∫£ AI operations<br> * Orchestrate: Detection ‚Üí LPR ‚Üí Tracking ‚Üí Anomaly Detection<br> */<br>export class AIService {<br>  /**<br>   * Process single image/frame<br>   * Full pipeline: Detect ‚Üí LPR ‚Üí Track ‚Üí Anomaly<br>   * <br>   * @param imageData - Image as base64 or File<br>   * @param imageWidth - Image width<br>   * @param imageHeight - Image height<br>   * @param parkingSpaces - Parking spaces for anomaly detection<br>   * @returns Processing result<br>   */<br>  async processImage(<br>    imageData: string | File,<br>    imageWidth: number,<br>    imageHeight: number,<br>    parkingSpaces: Array<{<br>      spaceId: string;<br>      occupied: boolean;<br>      polygon: Array<{x: number; y: number}>;<br>    }><br>  ): Promise<AIProcessingResult> {<br>    const startTime = Date.now();<br>    <br>    console.log('ü§ñ AI Processing started...');<br>    <br>    // Step 1: Object Detection<br>    console.log('  1Ô∏è‚É£ Detecting vehicles...');<br>    const detections = await mockObjectDetection.detectVehicles(<br>      imageData,<br>      imageWidth,<br>      imageHeight<br>    );<br>    <br>    // Step 2: License Plate Recognition<br>    console.log('  2Ô∏è‚É£ Recognizing license plates...');<br>    const enrichedDetections = [];<br>    <br>    for (const detection of detections) {<br>      // Mock: Crop vehicle from image (trong th·ª±c t·∫ø c·∫ßn crop th·∫≠t)<br>      const vehicleCrop = 'mock_cropped_image';<br>      <br>      // Recognize plate<br>      const lprResult = await mockLPR.recognizePlate(vehicleCrop);<br>      <br>      enrichedDetections.push({<br>        ...detection,<br>        licensePlate: lprResult.plateText,<br>        trackingId: '', // Will be assigned in next step<br>      });<br>    }<br>    <br>    // Step 3: Object Tracking<br>    console.log('  3Ô∏è‚É£ Updating tracking...');<br>    const trackingResults = await mockTracking.updateTracking(<br>      enrichedDetections.map(d => ({<br>        bbox: d.bbox,<br>        licensePlate: d.licensePlate,<br>      })),<br>      Date.now()<br>    );<br>    <br>    // Assign tracking IDs<br>    enrichedDetections.forEach((det, idx) => {<br>      if (trackingResults[idx]) {<br>        det.trackingId = trackingResults[idx].trackingId;<br>      }<br>    });<br>    <br>    // Step 4: Anomaly Detection<br>    console.log('  4Ô∏è‚É£ Detecting anomalies...');<br>    const vehicles = trackingResults.map(track => ({<br>      vehicleId: track.vehicleId || 'UNKNOWN',<br>      licensePlate: track.licensePlate,<br>      position: track.trajectory[track.trajectory.length - 1] || {x: 0, y: 0},<br>      checkInTime: Date.now() - Math.random() * 10 * 60 * 60 * 1000, // Mock<br>      registered: Math.random() > 0.1, // 90% registered<br>    }));<br>    <br>    const anomalies = await mockAnomalyDetection.detectAnomalies(<br>      vehicles,<br>      parkingSpaces<br>    );<br>    <br>    const processingTime = Date.now() - startTime;<br>    <br>    console.log(`‚úÖ AI Processing completed in ${processingTime}ms`);<br>    console.log(`   - Detected: ${enrichedDetections.length} vehicles`);<br>    console.log(`   - Anomalies: ${anomalies.length}`);<br>    <br>    return {<br>      detections: enrichedDetections,<br>      anomalies,<br>      summary: {<br>        totalVehicles: enrichedDetections.length,<br>        totalAnomalies: anomalies.length,<br>        processingTime,<br>      },<br>    };<br>  }<br>  <br>  /**<br>   * Process video (extract frames and process each)<br>   * @param videoFile - Video file<br>   * @param onProgress - Progress callback<br>   * @returns Aggregated results<br>   */<br>  async processVideo(<br>    videoFile: File,<br>    onProgress?: (progress: number) => void<br>  ): Promise<{<br>    totalFrames: number;<br>    processedFrames: number;<br>    allDetections: AIProcessingResult[];<br>  }> {<br>    console.log(`üìπ Processing video: ${videoFile.name}`);<br>    <br>    // Mock: In real implementation, use canvas to extract frames<br>    const totalFrames = 100; // Mock<br>    const framesToProcess = 10; // Process every 10th frame<br>    <br>    const allDetections: AIProcessingResult[] = [];<br>    <br>    for (let i = 0; i < framesToProcess; i++) {<br>      // Mock frame extraction<br>      const mockFrame = 'base64_frame_data';<br>      <br>      // Process frame<br>      const result = await this.processImage(<br>        mockFrame,<br>        1920,<br>        1080,<br>        [] // parkingSpaces should be passed from context<br>      );<br>      <br>      allDetections.push(result);<br>      <br>      // Report progress<br>      const progress = ((i + 1) / framesToProcess) * 100;<br>      if (onProgress) {<br>        onProgress(progress);<br>      }<br>      <br>      console.log(`  Frame ${i + 1}/${framesToProcess} processed`);<br>    }<br>    <br>    console.log('‚úÖ Video processing completed');<br>    <br>    return {<br>      totalFrames,<br>      processedFrames: framesToProcess,<br>      allDetections,<br>    };<br>  }<br>  <br>  /**<br>   * Reset all AI services (for testing)<br>   */<br>  reset(): void {<br>    mockObjectDetection.reset();<br>    mockLPR.reset();<br>    mockTracking.reset();<br>    mockAnomalyDetection.reset();<br>    console.log('üîÑ All AI services reset');<br>  }<br>}<br><br>// Export singleton<br>export const aiService = new AIService();<br>``` | **üéØ Usage Example**:<br>```typescript<br>import { aiService } from '@/services/ai/aiService';<br><br>// Process image<br>const result = await aiService.processImage(<br>  imageFile,<br>  1920,<br>  1080,<br>  parkingSpaces<br>);<br><br>console.log(result.detections);<br>console.log(result.anomalies);<br><br>// Process video v·ªõi progress<br>await aiService.processVideo(<br>  videoFile,<br>  (progress) => {<br>    console.log(`Progress: ${progress}%`);<br>  }<br>);<br>```<br><br>**üîÑ Replacing with Real AI**:<br>1. Implement real services<br>2. Change imports<br>3. Same interface!<br><br>```typescript<br>// Instead of mock...<br>import { realObjectDetection } <br>  from './realObjectDetection';<br>// Usage stays the same!<br>```<br><br>**‚ö° Performance**:<br>‚Ä¢ Mock: ~2-3s per frame<br>‚Ä¢ Real (CPU): ~100-200ms<br>‚Ä¢ Real (GPU): ~30-50ms<br><br>**üìä Video Processing**:<br>‚Ä¢ Extract frames: canvas API<br>‚Ä¢ Process every Nth frame (skip frames)<br>‚Ä¢ Aggregate results |

---

## ‚úÖ PHASE 1 & 2 COMPLETED!

**File 2.1 Summary**:
- ‚úÖ Setup project structure (React + TypeScript + Vite)
- ‚úÖ Configure Firebase + Emulator
- ‚úÖ Design Database Schema
- ‚úÖ Implement Security Rules
- ‚úÖ Create seed data
- ‚úÖ Mock Object Detection
- ‚úÖ Mock License Plate Recognition
- ‚úÖ Mock Object Tracking
- ‚úÖ Mock Anomaly Detection
- ‚úÖ Unified AI Service

**Next**: File 2.2 s·∫Ω cover **Phase 3 (Backend) & Phase 4 (Frontend Core)**

---

Perfect! üöÄ T√¥i s·∫Ω t·∫°o **File 2.2** ngay - Phase 3 & 4!

---

# üìÑ FILE 2.2: `pipeline_chi_tiet_part2.md`

```markdown
# Pipeline Chi Ti·∫øt - Part 2 (Phase 3 & 4)
# Backend & Frontend Core Features

> **File n√†y cover**: Phase 3 (Backend & API) v√† Phase 4 (Frontend Core: Home, Check-in, Live View, Alerts)

---

# PHASE 3: PH√ÅT TRI·ªÇN BACKEND & API

## 3.1. Generate Vehicle ID Function

| **C√¥ng vi·ªác (Task)** | **Ph√¢n t√≠ch & H∆∞·ªõng d·∫´n chi ti·∫øt** | **Code minh h·ªça** | **L∆∞u √Ω (Important Notes)** |
|----------------------|-----------------------------------|-------------------|----------------------------|
| T·∫°o function generate unique 7-digit Vehicle ID | **Requirements**:<br>- 7 characters<br>- Alphanumeric (A-Z, 0-9)<br>- Unique (check Firestore)<br>- Easy to type/remember<br><br>**Format**: ABC1234<br><br>**Collision handling**: Retry if exists | ```typescript<br>// src/utils/generateVehicleId.ts<br>import { collection, query, where, getDocs } from 'firebase/firestore';<br>import { db } from '@/config/firebase';<br><br>/**<br> * Generate unique 7-character vehicle ID<br> * Format: ABC1234 (3 letters + 4 digits)<br> * <br> * @returns Unique vehicle ID<br> */<br>export async function generateVehicleId(): Promise<string> {<br>  const MAX_ATTEMPTS = 10;<br>  <br>  for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {<br>    // Generate random ID<br>    const id = generateRandomId();<br>    <br>    // Check if exists in Firestore<br>    const exists = await checkIdExists(id);<br>    <br>    if (!exists) {<br>      console.log(`‚úÖ Generated vehicle ID: ${id}`);<br>      return id;<br>    }<br>    <br>    console.log(`‚ö†Ô∏è ID ${id} exists, retrying... (${attempt + 1}/${MAX_ATTEMPTS})`);<br>  }<br>  <br>  // Fallback: Add timestamp to ensure uniqueness<br>  const timestamp = Date.now().toString().slice(-4);<br>  return `ERR${timestamp}`;<br>}<br><br>/**<br> * Generate random 7-character ID<br> * Format: XXX9999 (3 letters + 4 digits)<br> */<br>function generateRandomId(): string {<br>  const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ'; // Exclude I, O (confusing)<br>  const digits = '0123456789';<br>  <br>  // Generate 3 random letters<br>  let id = '';<br>  for (let i = 0; i < 3; i++) {<br>    id += letters.charAt(Math.floor(Math.random() * letters.length));<br>  }<br>  <br>  // Generate 4 random digits<br>  for (let i = 0; i < 4; i++) {<br>    id += digits.charAt(Math.floor(Math.random() * digits.length));<br>  }<br>  <br>  return id;<br>}<br><br>/**<br> * Check if vehicle ID already exists in Firestore<br> */<br>async function checkIdExists(vehicleId: string): Promise<boolean> {<br>  try {<br>    const q = query(<br>      collection(db, 'vehicles'),<br>      where('vehicleId', '==', vehicleId)<br>    );<br>    <br>    const snapshot = await getDocs(q);<br>    return !snapshot.empty;<br>  } catch (error) {<br>    console.error('Error checking ID existence:', error);<br>    return false; // Assume doesn't exist on error<br>  }<br>}<br><br>/**<br> * Validate vehicle ID format<br> */<br>export function validateVehicleId(id: string): boolean {<br>  // Must be exactly 7 characters<br>  if (id.length !== 7) return false;<br>  <br>  // First 3 must be letters<br>  if (!/^[A-Z]{3}/.test(id)) return false;<br>  <br>  // Last 4 must be digits<br>  if (!/[0-9]{4}$/.test(id)) return false;<br>  <br>  return true;<br>}<br>``` | **üéØ ID Format**:<br>‚Ä¢ Pattern: `[A-Z]{3}[0-9]{4}`<br>‚Ä¢ Example: ABC1234, XYZ5678<br>‚Ä¢ Total combinations: 26¬≥ √ó 10‚Å¥ = 175,760,000<br>‚Ä¢ Collision probability: Very low<br><br>**‚ö†Ô∏è Excluded Characters**:<br>‚Ä¢ I, O (look like 1, 0)<br>‚Ä¢ Makes IDs easier to read<br><br>**üîÑ Retry Logic**:<br>‚Ä¢ Max 10 attempts<br>‚Ä¢ If all fail: Use timestamp fallback<br>‚Ä¢ Log warnings for monitoring<br><br>**‚úÖ Usage**:<br>```typescript<br>const vehicleId = await generateVehicleId();<br>// Returns: "ABC1234"<br><br>// Validate<br>if (!validateVehicleId(vehicleId)) {<br>  throw new Error('Invalid ID');<br>}<br>```<br><br>**üìä Performance**:<br>‚Ä¢ Average: 1 Firestore read<br>‚Ä¢ Worst case: 10 reads<br>‚Ä¢ Consider caching used IDs in memory |

## 3.2. Vehicle Check-in Service

| **C√¥ng vi·ªác (Task)** | **Ph√¢n t√≠ch & H∆∞·ªõng d·∫´n chi ti·∫øt** | **Code minh h·ªça** | **L∆∞u √Ω (Important Notes)** |
|----------------------|-----------------------------------|-------------------|----------------------------|
| T·∫°o service x·ª≠ l√Ω check-in vehicle | **Flow**:<br>1. Validate input data<br>2. Generate vehicle ID<br>3. Upload image to Storage<br>4. Save to Firestore<br>5. Return success v·ªõi ID<br><br>**No email** (theo y√™u c·∫ßu) | ```typescript<br>// src/services/vehicleService.ts<br>import { <br>  collection, <br>  doc, <br>  setDoc, <br>  Timestamp,<br>  getDoc<br>} from 'firebase/firestore';<br>import { <br>  ref, <br>  uploadBytes, <br>  getDownloadURL <br>} from 'firebase/storage';<br>import { db, storage } from '@/config/firebase';<br>import { generateVehicleId, validateVehicleId } from '@/utils/generateVehicleId';<br>import type { Vehicle } from '@/types/firestore.types';<br><br>/**<br> * Check-in Request Data<br> */<br>export interface CheckInRequest {<br>  ownerName: string;<br>  licensePlate: string;<br>  vehicleType: 'car' | 'motorbike';<br>  imageFile?: File; // Optional vehicle image<br>}<br><br>/**<br> * Check-in Response<br> */<br>export interface CheckInResponse {<br>  success: boolean;<br>  vehicleId: string;<br>  message: string;<br>  vehicle?: Vehicle;<br>}<br><br>/**<br> * Vehicle Service<br> * X·ª≠ l√Ω check-in, check-out, v√† queries<br> */<br>export class VehicleService {<br>  /**<br>   * Check-in vehicle<br>   */<br>  async checkIn(request: CheckInRequest): Promise<CheckInResponse> {<br>    try {<br>      console.log('üöó Processing check-in...', request.licensePlate);<br>      <br>      // 1. Validate input<br>      this.validateCheckInRequest(request);<br>      <br>      // 2. Generate unique vehicle ID<br>      const vehicleId = await generateVehicleId();<br>      <br>      // 3. Upload image if provided<br>      let imageUrl = 'https://placehold.co/400x300/blue/white?text=' + <br>                     encodeURIComponent(request.licensePlate);<br>      <br>      if (request.imageFile) {<br>        imageUrl = await this.uploadVehicleImage(vehicleId, request.imageFile);<br>      }<br>      <br>      // 4. Create vehicle document<br>      const vehicle: Vehicle = {<br>        vehicleId,<br>        licensePlate: request.licensePlate.toUpperCase(),<br>        ownerName: request.ownerName,<br>        vehicleType: request.vehicleType,<br>        checkInTime: Timestamp.now(),<br>        checkOutTime: null,<br>        status: 'active',<br>        imageUrl,<br>        createdAt: Timestamp.now(),<br>      };<br>      <br>      // 5. Save to Firestore<br>      await setDoc(doc(db, 'vehicles', vehicleId), vehicle);<br>      <br>      console.log(`‚úÖ Check-in successful: ${vehicleId}`);<br>      <br>      return {<br>        success: true,<br>        vehicleId,<br>        message: 'ƒêƒÉng k√Ω th√†nh c√¥ng! Vui l√≤ng l∆∞u ID xe c·ªßa b·∫°n.',<br>        vehicle,<br>      };<br>    } catch (error) {<br>      console.error('‚ùå Check-in error:', error);<br>      <br>      return {<br>        success: false,<br>        vehicleId: '',<br>        message: error instanceof Error ? error.message : 'ƒêƒÉng k√Ω th·∫•t b·∫°i',<br>      };<br>    }<br>  }<br>  <br>  /**<br>   * Check-out vehicle<br>   */<br>  async checkOut(vehicleId: string): Promise<{success: boolean; message: string}> {<br>    try {<br>      console.log('üöô Processing check-out...', vehicleId);<br>      <br>      // Validate ID format<br>      if (!validateVehicleId(vehicleId)) {<br>        throw new Error('Invalid vehicle ID format');<br>      }<br>      <br>      // Get vehicle document<br>      const vehicleRef = doc(db, 'vehicles', vehicleId);<br>      const vehicleSnap = await getDoc(vehicleRef);<br>      <br>      if (!vehicleSnap.exists()) {<br>        throw new Error('Vehicle not found');<br>      }<br>      <br>      const vehicle = vehicleSnap.data() as Vehicle;<br>      <br>      // Check if already checked out<br>      if (vehicle.status === 'checked_out') {<br>        throw new Error('Vehicle already checked out');<br>      }<br>      <br>      // Update vehicle<br>      await setDoc(vehicleRef, {<br>        ...vehicle,<br>        checkOutTime: Timestamp.now(),<br>        status: 'checked_out',<br>      });<br>      <br>      // Update parking space if occupied<br>      // (Implementation depends on tracking logic)<br>      <br>      console.log(`‚úÖ Check-out successful: ${vehicleId}`);<br>      <br>      return {<br>        success: true,<br>        message: 'Check-out th√†nh c√¥ng!',<br>      };<br>    } catch (error) {<br>      console.error('‚ùå Check-out error:', error);<br>      <br>      return {<br>        success: false,<br>        message: error instanceof Error ? error.message : 'Check-out th·∫•t b·∫°i',<br>      };<br>    }<br>  }<br>  <br>  /**<br>   * Get vehicle by ID<br>   */<br>  async getVehicle(vehicleId: string): Promise<Vehicle | null> {<br>    try {<br>      const vehicleRef = doc(db, 'vehicles', vehicleId);<br>      const vehicleSnap = await getDoc(vehicleRef);<br>      <br>      if (vehicleSnap.exists()) {<br>        return vehicleSnap.data() as Vehicle;<br>      }<br>      <br>      return null;<br>    } catch (error) {<br>      console.error('Error getting vehicle:', error);<br>      return null;<br>    }<br>  }<br>  <br>  // ========== PRIVATE METHODS ==========<br>  <br>  /**<br>   * Validate check-in request<br>   */<br>  private validateCheckInRequest(request: CheckInRequest): void {<br>    // Validate owner name<br>    if (!request.ownerName || request.ownerName.trim().length < 2) {<br>      throw new Error('T√™n ph·∫£i c√≥ √≠t nh·∫•t 2 k√Ω t·ª±');<br>    }<br>    <br>    // Validate license plate<br>    if (!this.validateLicensePlate(request.licensePlate)) {<br>      throw new Error('Bi·ªÉn s·ªë xe kh√¥ng h·ª£p l·ªá (format: XX(X)-YYYYY)');<br>    }<br>    <br>    // Validate vehicle type<br>    if (!['car', 'motorbike'].includes(request.vehicleType)) {<br>      throw new Error('Lo·∫°i xe kh√¥ng h·ª£p l·ªá');<br>    }<br>  }<br>  <br>  /**<br>   * Validate Vietnamese license plate format<br>   */<br>  private validateLicensePlate(plate: string): boolean {<br>    // Vietnamese format: XX(X)-YYYYY<br>    const regex = /^[0-9]{2}[A-Z]-[0-9]{4,5}$/;<br>    return regex.test(plate.toUpperCase());<br>  }<br>  <br>  /**<br>   * Upload vehicle image to Firebase Storage<br>   */<br>  private async uploadVehicleImage(vehicleId: string, file: File): Promise<string> {<br>    try {<br>      // Create unique filename<br>      const timestamp = Date.now();<br>      const filename = `vehicles/${vehicleId}/${timestamp}_${file.name}`;<br>      <br>      // Create storage reference<br>      const storageRef = ref(storage, filename);<br>      <br>      // Upload file<br>      await uploadBytes(storageRef, file);<br>      <br>      // Get download URL<br>      const downloadUrl = await getDownloadURL(storageRef);<br>      <br>      console.log(`üì∏ Image uploaded: ${filename}`);<br>      <br>      return downloadUrl;<br>    } catch (error) {<br>      console.error('Error uploading image:', error);<br>      // Return placeholder on error<br>      return 'https://placehold.co/400x300/gray/white?text=Upload+Failed';<br>    }<br>  }<br>}<br><br>// Export singleton<br>export const vehicleService = new VehicleService();<br>``` | **‚úÖ Validation Rules**:<br>‚Ä¢ Owner name: ‚â• 2 characters<br>‚Ä¢ License plate: Vietnamese format<br>‚Ä¢ Vehicle type: car or motorbike<br><br>**üì∏ Image Upload**:<br>‚Ä¢ Path: `vehicles/{vehicleId}/{timestamp}_{filename}`<br>‚Ä¢ Fallback: Placeholder if upload fails<br>‚Ä¢ Max size: Configure in Storage rules<br><br>**üîí Security**:<br>‚Ä¢ Input validation critical<br>‚Ä¢ Sanitize license plate (uppercase)<br>‚Ä¢ Check file type for images<br><br>**üíæ Storage Rules**:<br>```javascript<br>// storage.rules<br>match /vehicles/{vehicleId}/{filename} {<br>  allow write: if request.auth != null &&<br>    request.resource.size < 5 * 1024 * 1024 && // 5MB<br>    request.resource.contentType.matches('image/.*');<br>  allow read: if request.auth != null;<br>}<br>```<br><br>**üéØ Usage Example**:<br>```typescript<br>const response = await vehicleService.checkIn({<br>  ownerName: 'Nguyen Van A',<br>  licensePlate: '30A-12345',<br>  vehicleType: 'car',<br>  imageFile: selectedFile<br>});<br><br>if (response.success) {<br>  alert(`ID xe: ${response.vehicleId}`);<br>}<br>``` |

## 3.3. Video Processing Service

| **C√¥ng vi·ªác (Task)** | **Ph√¢n t√≠ch & H∆∞·ªõng d·∫´n chi ti·∫øt** | **Code minh h·ªça** | **L∆∞u √Ω (Important Notes)** |
|----------------------|-----------------------------------|-------------------|----------------------------|
| T·∫°o service x·ª≠ l√Ω uploaded video | **Steps**:<br>1. Upload video to Storage<br>2. Extract frames using Canvas API<br>3. Process frames v·ªõi AI service<br>4. Save results to Firestore<br>5. Update progress real-time<br><br>**Frame extraction**: Client-side v·ªõi Canvas | ```typescript<br>// src/services/videoProcessingService.ts<br>import { ref, uploadBytes, getDownloadURL } from 'firebase/storage';<br>import { collection, doc, setDoc, updateDoc } from 'firebase/firestore';<br>import { storage, db } from '@/config/firebase';<br>import { aiService } from './ai/aiService';<br>import type { ParkingSpace } from '@/types/firestore.types';<br><br>/**<br> * Video Processing Progress<br> */<br>export interface VideoProcessingProgress {<br>  stage: 'uploading' | 'extracting' | 'processing' | 'completed' | 'error';<br>  progress: number; // 0-100<br>  message: string;<br>  currentFrame?: number;<br>  totalFrames?: number;<br>}<br><br>/**<br> * Video Processing Result<br> */<br>export interface VideoProcessingResult {<br>  success: boolean;<br>  videoUrl: string;<br>  totalFrames: number;<br>  processedFrames: number;<br>  detectionsCount: number;<br>  anomaliesCount: number;<br>}<br><br>/**<br> * Video Processing Service<br> */<br>export class VideoProcessingService {<br>  /**<br>   * Process uploaded video<br>   * <br>   * @param videoFile - Video file<br>   * @param parkingSpaces - Parking spaces for anomaly detection<br>   * @param onProgress - Progress callback<br>   * @returns Processing result<br>   */<br>  async processVideo(<br>    videoFile: File,<br>    parkingSpaces: ParkingSpace[],<br>    onProgress?: (progress: VideoProcessingProgress) => void<br>  ): Promise<VideoProcessingResult> {<br>    try {<br>      // Stage 1: Upload video<br>      this.reportProgress(onProgress, {<br>        stage: 'uploading',<br>        progress: 0,<br>        message: 'ƒêang upload video...',<br>      });<br>      <br>      const videoUrl = await this.uploadVideo(videoFile);<br>      <br>      this.reportProgress(onProgress, {<br>        stage: 'uploading',<br>        progress: 30,<br>        message: 'Upload ho√†n t·∫•t!',<br>      });<br>      <br>      // Stage 2: Extract frames<br>      this.reportProgress(onProgress, {<br>        stage: 'extracting',<br>        progress: 30,<br>        message: 'ƒêang tr√≠ch xu·∫•t frames...',<br>      });<br>      <br>      const frames = await this.extractFrames(videoFile, 10); // Extract 10 frames<br>      <br>      this.reportProgress(onProgress, {<br>        stage: 'extracting',<br>        progress: 50,<br>        message: `ƒê√£ tr√≠ch xu·∫•t ${frames.length} frames`,<br>        totalFrames: frames.length,<br>      });<br>      <br>      // Stage 3: Process frames v·ªõi AI<br>      this.reportProgress(onProgress, {<br>        stage: 'processing',<br>        progress: 50,<br>        message: 'ƒêang x·ª≠ l√Ω v·ªõi AI...',<br>        totalFrames: frames.length,<br>      });<br>      <br>      let totalDetections = 0;<br>      let totalAnomalies = 0;<br>      <br>      for (let i = 0; i < frames.length; i++) {<br>        const frame = frames[i];<br>        <br>        // Process frame<br>        const result = await aiService.processImage(<br>          frame.data,<br>          frame.width,<br>          frame.height,<br>          parkingSpaces<br>        );<br>        <br>        totalDetections += result.summary.totalVehicles;<br>        totalAnomalies += result.summary.totalAnomalies;<br>        <br>        // Save detections to Firestore (if needed)<br>        // await this.saveDetections(result);<br>        <br>        // Report progress<br>        const progress = 50 + ((i + 1) / frames.length) * 50;<br>        this.reportProgress(onProgress, {<br>          stage: 'processing',<br>          progress,<br>          message: `ƒêang x·ª≠ l√Ω frame ${i + 1}/${frames.length}...`,<br>          currentFrame: i + 1,<br>          totalFrames: frames.length,<br>        });<br>      }<br>      <br>      // Stage 4: Complete<br>      this.reportProgress(onProgress, {<br>        stage: 'completed',<br>        progress: 100,<br>        message: 'X·ª≠ l√Ω ho√†n t·∫•t!',<br>      });<br>      <br>      console.log(`‚úÖ Video processing completed`);<br>      console.log(`   - Frames: ${frames.length}`);<br>      console.log(`   - Detections: ${totalDetections}`);<br>      console.log(`   - Anomalies: ${totalAnomalies}`);<br>      <br>      return {<br>        success: true,<br>        videoUrl,<br>        totalFrames: frames.length,<br>        processedFrames: frames.length,<br>        detectionsCount: totalDetections,<br>        anomaliesCount: totalAnomalies,<br>      };<br>    } catch (error) {<br>      console.error('‚ùå Video processing error:', error);<br>      <br>      this.reportProgress(onProgress, {<br>        stage: 'error',<br>        progress: 0,<br>        message: error instanceof Error ? error.message : 'L·ªói x·ª≠ l√Ω video',<br>      });<br>      <br>      throw error;<br>    }<br>  }<br>  <br>  /**<br>   * Upload video to Firebase Storage<br>   */<br>  private async uploadVideo(videoFile: File): Promise<string> {<br>    const timestamp = Date.now();<br>    const filename = `videos/${timestamp}_${videoFile.name}`;<br>    <br>    const storageRef = ref(storage, filename);<br>    await uploadBytes(storageRef, videoFile);<br>    <br>    const downloadUrl = await getDownloadURL(storageRef);<br>    console.log(`üìπ Video uploaded: ${filename}`);<br>    <br>    return downloadUrl;<br>  }<br>  <br>  /**<br>   * Extract frames from video using Canvas API<br>   * <br>   * @param videoFile - Video file<br>   * @param numFrames - Number of frames to extract<br>   * @returns Array of frame data<br>   */<br>  private async extractFrames(<br>    videoFile: File,<br>    numFrames: number = 10<br>  ): Promise<Array<{data: string; width: number; height: number}>> {<br>    return new Promise((resolve, reject) => {<br>      const video = document.createElement('video');<br>      const canvas = document.createElement('canvas');<br>      const ctx = canvas.getContext('2d');<br>      <br>      if (!ctx) {<br>        reject(new Error('Cannot get canvas context'));<br>        return;<br>      }<br>      <br>      const frames: Array<{data: string; width: number; height: number}> = [];<br>      <br>      video.addEventListener('loadedmetadata', () => {<br>        canvas.width = video.videoWidth;<br>        canvas.height = video.videoHeight;<br>        <br>        const duration = video.duration;<br>        const interval = duration / numFrames;<br>        <br>        let currentFrame = 0;<br>        <br>        const extractFrame = () => {<br>          if (currentFrame >= numFrames) {<br>            resolve(frames);<br>            return;<br>          }<br>          <br>          const time = currentFrame * interval;<br>          video.currentTime = time;<br>          <br>          video.addEventListener('seeked', function onSeeked() {<br>            // Draw video frame to canvas<br>            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);<br>            <br>            // Get frame as base64<br>            const frameData = canvas.toDataURL('image/jpeg', 0.8);<br>            <br>            frames.push({<br>              data: frameData,<br>              width: canvas.width,<br>              height: canvas.height,<br>            });<br>            <br>            currentFrame++;<br>            video.removeEventListener('seeked', onSeeked);<br>            extractFrame();<br>          }, { once: true });<br>        };<br>        <br>        extractFrame();<br>      });<br>      <br>      video.addEventListener('error', (e) => {<br>        reject(new Error('Error loading video'));<br>      });<br>      <br>      // Load video<br>      video.src = URL.createObjectURL(videoFile);<br>      video.load();<br>    });<br>  }<br>  <br>  /**<br>   * Report progress to callback<br>   */<br>  private reportProgress(<br>    callback: ((progress: VideoProcessingProgress) => void) | undefined,<br>    progress: VideoProcessingProgress<br>  ): void {<br>    if (callback) {<br>      callback(progress);<br>    }<br>  }<br>}<br><br>// Export singleton<br>export const videoProcessingService = new VideoProcessingService();<br>``` | **üé¨ Frame Extraction**:<br>‚Ä¢ Uses HTML5 Video + Canvas<br>‚Ä¢ Extract frames at equal intervals<br>‚Ä¢ Convert to base64 JPEG<br><br>**üìä Processing Strategy**:<br>‚Ä¢ Don't process ALL frames (slow)<br>‚Ä¢ Sample N frames evenly<br>‚Ä¢ N = 10-30 depending on video length<br><br>**‚ö° Performance**:<br>‚Ä¢ Client-side extraction: Fast<br>‚Ä¢ No server roundtrip for frames<br>‚Ä¢ Progress updates real-time<br><br>**üí° Optimization Tips**:<br>```typescript<br>// Adaptive sampling<br>const videoLength = video.duration;<br>const framesToExtract = Math.min(<br>  Math.ceil(videoLength / 2), // 1 frame per 2s<br>  30 // Max 30 frames<br>);<br>```<br><br>**üîß Browser Compatibility**:<br>‚Ä¢ Chrome/Edge: ‚úÖ<br>‚Ä¢ Firefox: ‚úÖ<br>‚Ä¢ Safari: ‚úÖ (may need polyfill)<br><br>**üì¶ Storage Limits**:<br>‚Ä¢ Video max size: 100MB<br>‚Ä¢ Set in Storage Rules<br>‚Ä¢ Compress video before upload if needed |

---

# PHASE 4: PH√ÅT TRI·ªÇN FRONTEND - CORE FEATURES

## 4.1. Setup Routing & Layout

| **C√¥ng vi·ªác (Task)** | **Ph√¢n t√≠ch & H∆∞·ªõng d·∫´n chi ti·∫øt** | **Code minh h·ªça** | **L∆∞u √Ω (Important Notes)** |
|----------------------|-----------------------------------|-------------------|----------------------------|
| Setup React Router v·ªõi 6 tabs | **Routes**:<br>- `/` - Home<br>- `/checkin` - Check-in<br>- `/liveview` - Live View<br>- `/alerts` - Alerts<br>- `/admin` - Admin (protected)<br>- `/future` - Future Features<br><br>**Layout**: Shared navigation | ```typescript<br>// src/App.tsx<br>import { BrowserRouter, Routes, Route } from 'react-router-dom';<br>import { Layout } from './components/Layout';<br>import { HomePage } from './pages/HomePage';<br>import { CheckInPage } from './pages/CheckInPage';<br>import { LiveViewPage } from './pages/LiveViewPage';<br>import { AlertsPage } from './pages/AlertsPage';<br>import { AdminPage } from './pages/AdminPage';<br>import { FuturePage } from './pages/FuturePage';<br>import { ProtectedRoute } from './components/ProtectedRoute';<br><br>function App() {<br>  return (<br>    <BrowserRouter><br>      <Routes><br>        <Route path="/" element={<Layout />}><br>          <Route index element={<HomePage />} /><br>          <Route path="checkin" element={<CheckInPage />} /><br>          <Route path="liveview" element={<LiveViewPage />} /><br>          <Route path="alerts" element={<AlertsPage />} /><br>          <Route <br>            path="admin" <br>            element={<br>              <ProtectedRoute requiredRole="admin"><br>                <AdminPage /><br>              </ProtectedRoute><br>            } <br>          /><br>          <Route path="future" element={<FuturePage />} /><br>        </Route><br>      </Routes><br>    </BrowserRouter><br>  );<br>}<br><br>export default App;<br><br>// src/components/Layout.tsx<br>import { Outlet } from 'react-router-dom';<br>import { Navigation } from './Navigation';<br><br>export function Layout() {<br>  return (<br>    <div className="min-h-screen bg-gray-50"><br>      {/* Navigation Bar */}<br>      <Navigation /><br>      <br>      {/* Page Content */}<br>      <main className="container mx-auto px-4 py-6"><br>        <Outlet /><br>      </main><br>    </div><br>  );<br>}<br><br>// src/components/Navigation.tsx<br>import { Link, useLocation } from 'react-router-dom';<br>import { useAuth } from '@/hooks/useAuth'; // To be implemented<br><br>export function Navigation() {<br>  const location = useLocation();<br>  const { user } = useAuth();<br>  <br>  const isActive = (path: string) => location.pathname === path;<br>  <br>  const navLinkClass = (path: string) => `<br>    px-4 py-2 rounded-lg transition<br>    ${isActive(path) <br>      ? 'bg-primary-600 text-white' <br>      : 'text-gray-700 hover:bg-gray-200'<br>    }<br>  `;<br>  <br>  return (<br>    <nav className="bg-white shadow-md"><br>      <div className="container mx-auto px-4"><br>        <div className="flex items-center justify-between h-16"><br>          {/* Logo */}<br>          <Link to="/" className="flex items-center space-x-2"><br>            <span className="text-2xl">üÖøÔ∏è</span><br>            <span className="font-bold text-xl">Smart Parking</span><br>          </Link><br>          <br>          {/* Nav Links */}<br>          <div className="hidden md:flex space-x-2"><br>            <Link to="/" className={navLinkClass('/')}><br>              üè† Home<br>            </Link><br>            <Link to="/checkin" className={navLinkClass('/checkin')}><br>              ‚úçÔ∏è Check-in<br>            </Link><br>            <Link to="/liveview" className={navLinkClass('/liveview')}><br>              üëÅÔ∏è Live View<br>            </Link><br>            <Link to="/alerts" className={navLinkClass('/alerts')}><br>              ‚ö†Ô∏è Alerts<br>            </Link><br>            {user?.role === 'admin' && (<br>              <Link to="/admin" className={navLinkClass('/admin')}><br>                üîß Admin<br>              </Link><br>            )}<br>            <Link to="/future" className={navLinkClass('/future')}><br>              üöÄ Future<br>            </Link><br>          </div><br>          <br>          {/* User Menu */}<br>          <div className="flex items-center space-x-4"><br>            <span className="text-sm text-gray-600"><br>              {user?.displayName || 'Guest'}<br>            </span><br>            {user?.role === 'admin' && (<br>              <span className="px-2 py-1 bg-red-100 text-red-800 text-xs rounded"><br>                ADMIN<br>              </span><br>            )}<br>          </div><br>        </div><br>      </div><br>      <br>      {/* Mobile Menu (simplified) */}<br>      <div className="md:hidden px-4 py-2 space-y-1"><br>        <Link to="/" className="block px-4 py-2">üè† Home</Link><br>        <Link to="/checkin" className="block px-4 py-2">‚úçÔ∏è Check-in</Link><br>        <Link to="/liveview" className="block px-4 py-2">üëÅÔ∏è Live View</Link><br>        <Link to="/alerts" className="block px-4 py-2">‚ö†Ô∏è Alerts</Link><br>        {user?.role === 'admin' && (<br>          <Link to="/admin" className="block px-4 py-2">üîß Admin</Link><br>        )}<br>        <Link to="/future" className="block px-4 py-2">üöÄ Future</Link><br>      </div><br>    </nav><br>  );<br>}<br><br>// src/components/ProtectedRoute.tsx<br>import { Navigate } from 'react-router-dom';<br>import { useAuth } from '@/hooks/useAuth';<br>import type { ReactNode } from 'react';<br><br>interface ProtectedRouteProps {<br>  children: ReactNode;<br>  requiredRole?: 'user' | 'admin';<br>}<br><br>export function ProtectedRoute({ children, requiredRole }: ProtectedRouteProps) {<br>  const { user, loading } = useAuth();<br>  <br>  if (loading) {<br>    return <div>Loading...</div>;<br>  }<br>  <br>  if (!user) {<br>    return <Navigate to="/" replace />;<br>  }<br>  <br>  if (requiredRole && user.role !== requiredRole) {<br>    return <Navigate to="/" replace />;<br>  }<br>  <br>  return <>{children}</>;<br>}<br>``` | **üì± Responsive Design**:<br>‚Ä¢ Desktop: Horizontal nav<br>‚Ä¢ Mobile: Hamburger menu<br>‚Ä¢ Tailwind breakpoints: `md:`, `lg:`<br><br>**üîí Protected Routes**:<br>‚Ä¢ Check authentication<br>‚Ä¢ Check role (user vs admin)<br>‚Ä¢ Redirect if unauthorized<br><br>**üé® Active Link Styling**:<br>‚Ä¢ Highlight current page<br>‚Ä¢ Change color/background<br>‚Ä¢ Use `useLocation` hook<br><br>**‚ôø Accessibility**:<br>‚Ä¢ Semantic HTML (`<nav>`, `<main>`)<br>‚Ä¢ Keyboard navigation<br>‚Ä¢ ARIA labels if needed<br><br>**üí° Navigation UX**:<br>‚Ä¢ Sticky nav on scroll (optional)<br>‚Ä¢ Smooth transitions<br>‚Ä¢ Clear visual hierarchy<br><br>**üîß Next Steps**:<br>Need to implement `useAuth` hook for authentication state |

B·∫°n ∆°i, file n√†y ƒëang d√†i qu√° r·ªìi (ƒë√£ h∆°n 1500 d√≤ng)! 

T√¥i mu·ªën h·ªèi: **B·∫°n c√≥ mu·ªën t√¥i:**

1. ‚úÖ **Ti·∫øp t·ª•c chi ti·∫øt h·∫øt Phase 4** (c√≤n l·∫°i: Home Page, Check-in Page, Live View Page, Alerts Page) - File s·∫Ω ~3000 d√≤ng
2. ‚è∏Ô∏è **D·ª´ng ·ªü ƒë√¢y**, t·∫°o file 2.3 ri√™ng cho ph·∫ßn c√≤n l·∫°i
3. üìù **T√≥m t·∫Øt ng·∫Øn g·ªçn** c√°c pages c√≤n l·∫°i thay v√¨ code ƒë·∫ßy ƒë·ªß

**Recommend**: Option 2 - Chia th√†nh 3 files c√¢n b·∫±ng h∆°n!

B·∫°n ch·ªçn n√†o? üòä



Perfect! üéØ T√¥i s·∫Ω **k·∫øt th√∫c File 2.2 ·ªü ƒë√¢y** v√† t·∫°o **File 2.3** cho ph·∫ßn c√≤n l·∫°i!

---

## **K·∫æT TH√öC FILE 2.2**

```markdown
---

## ‚úÖ PHASE 3 COMPLETED & PHASE 4 STARTED!

**File 2.2 Summary**:

### Phase 3: Backend & API ‚úÖ
- ‚úÖ Generate Vehicle ID (7-digit unique)
- ‚úÖ Vehicle Check-in Service
- ‚úÖ Vehicle Check-out Service
- ‚úÖ Video Processing Service (upload + extract frames)
- ‚úÖ Integration v·ªõi Mock AI Services

### Phase 4: Frontend Core (Partial) üöß
- ‚úÖ React Router setup (6 routes)
- ‚úÖ Layout & Navigation component
- ‚úÖ Protected Routes (role-based)
- ‚úÖ Responsive design structure

**Next in File 2.3**:
- üîú Phase 4 continued: Home Page, Check-in Page, Live View Page, Alerts Page
- üîú Phase 5: Admin Dashboard (4 modules)
- üîú Phase 6: Testing, Optimization & Deployment

---

**K·∫æT TH√öC FILE 2.2** üéâ

üìÑ Ti·∫øp t·ª•c v·ªõi **File 2.3** ƒë·ªÉ ho√†n th√†nh to√†n b·ªô pipeline!
```

---

Gi·ªù t√¥i t·∫°o **FILE 2.3** ngay! üöÄ

---

# üìÑ FILE 2.3: `pipeline_chi_tiet_part3.md`

```markdown
# Pipeline Chi Ti·∫øt - Part 3 (Phase 4 continued, Phase 5 & 6)
# Frontend Pages, Admin Features, Testing & Deployment

> **File n√†y cover**: Phase 4 (ti·∫øp) - 4 Pages ch√≠nh, Phase 5 - Admin Dashboard, Phase 6 - Testing & Optimization

---

# PHASE 4: FRONTEND CORE (CONTINUED)

## 4.2. Home Page - Status Cards

| **C√¥ng vi·ªác (Task)** | **Ph√¢n t√≠ch & H∆∞·ªõng d·∫´n chi ti·∫øt** | **Code minh h·ªça** | **L∆∞u √Ω (Important Notes)** |
|----------------------|-----------------------------------|-------------------|----------------------------|
| T·∫°o Home Page v·ªõi real-time status cards | **Features**:<br>- 4 status cards (Total, Occupied, Available, Alerts)<br>- Real-time updates t·ª´ Firestore<br>- Color indicators<br>- Quick actions<br>- Notifications area | ```typescript<br>// src/pages/HomePage.tsx<br>import { useEffect, useState } from 'react';<br>import { collection, onSnapshot, query, where } from 'firebase/firestore';<br>import { db } from '@/config/firebase';<br><br>interface Stats {<br>  totalSpaces: number;<br>  occupiedSpaces: number;<br>  availableSpaces: number;<br>  unresolvedAlerts: number;<br>}<br><br>export function HomePage() {<br>  const [stats, setStats] = useState<Stats>({<br>    totalSpaces: 0,<br>    occupiedSpaces: 0,<br>    availableSpaces: 0,<br>    unresolvedAlerts: 0,<br>  });<br>  const [loading, setLoading] = useState(true);<br>  <br>  useEffect(() => {<br>    // Real-time listener for parking spaces<br>    const unsubSpaces = onSnapshot(<br>      collection(db, 'parkingSpaces'),<br>      (snapshot) => {<br>        const spaces = snapshot.docs.map(doc => doc.data());<br>        const occupied = spaces.filter(s => s.occupied).length;<br>        <br>        setStats(prev => ({<br>          ...prev,<br>          totalSpaces: spaces.length,<br>          occupiedSpaces: occupied,<br>          availableSpaces: spaces.length - occupied,<br>        }));<br>        <br>        setLoading(false);<br>      }<br>    );<br>    <br>    // Real-time listener for alerts<br>    const unsubAlerts = onSnapshot(<br>      query(collection(db, 'alerts'), where('resolved', '==', false)),<br>      (snapshot) => {<br>        setStats(prev => ({<br>          ...prev,<br>          unresolvedAlerts: snapshot.size,<br>        }));<br>      }<br>    );<br>    <br>    return () => {<br>      unsubSpaces();<br>      unsubAlerts();<br>    };<br>  }, []);<br>  <br>  const occupancyRate = stats.totalSpaces > 0 <br>    ? (stats.occupiedSpaces / stats.totalSpaces) * 100 <br>    : 0;<br>  <br>  const getOccupancyColor = () => {<br>    if (occupancyRate < 70) return 'text-success';<br>    if (occupancyRate < 90) return 'text-warning';<br>    return 'text-danger';<br>  };<br>  <br>  if (loading) {<br>    return (<br>      <div className="flex items-center justify-center h-96"><br>        <div className="text-xl">Loading...</div><br>      </div><br>    );<br>  }<br>  <br>  return (<br>    <div className="space-y-6"><br>      {/* Header */}<br>      <div className="text-center"><br>        <h1 className="text-4xl font-bold mb-2">üÖøÔ∏è Smart Parking System</h1><br>        <p className="text-gray-600"><br>          C·∫≠p nh·∫≠t: {new Date().toLocaleString('vi-VN')}<br>        </p><br>      </div><br>      <br>      {/* Status Cards Grid */}<br>      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6"><br>        {/* Card 1: Total Spaces */}<br>        <StatusCard<br>          icon="üìä"<br>          title="T·ªîNG V·ªä TR√ç ƒê·ªñ"<br>          value={stats.totalSpaces}<br>          subtitle="v·ªã tr√≠"<br>          bgColor="bg-blue-500"<br>        /><br>        <br>        {/* Card 2: Occupied */}<br>        <StatusCard<br>          icon="üöó"<br>          title="ƒê√É CHI·∫æM"<br>          value={stats.occupiedSpaces}<br>          subtitle={`xe ƒëang ƒë·ªó (${occupancyRate.toFixed(1)}%)`}<br>          bgColor={<br>            occupancyRate < 70 ? 'bg-green-500' :<br>            occupancyRate < 90 ? 'bg-orange-500' :<br>            'bg-red-500'<br>          }<br>        /><br>        <br>        {/* Card 3: Available */}<br>        <StatusCard<br>          icon="‚úÖ"<br>          title="KH·∫¢ D·ª§NG"<br>          value={stats.availableSpaces}<br>          subtitle="v·ªã tr√≠ tr·ªëng"<br>          bgColor="bg-green-500"<br>        /><br>        <br>        {/* Card 4: Alerts */}<br>        <StatusCard<br>          icon="‚ö†Ô∏è"<br>          title="C·∫¢NH B√ÅO"<br>          value={stats.unresolvedAlerts}<br>          subtitle="s·ª± ki·ªán c·∫ßn x·ª≠ l√Ω"<br>          bgColor="bg-yellow-500"<br>        /><br>      </div><br>      <br>      {/* Quick Actions */}<br>      <div className="bg-white rounded-lg shadow p-6"><br>        <h2 className="text-xl font-bold mb-4">Thao t√°c nhanh</h2><br>        <div className="grid grid-cols-1 md:grid-cols-3 gap-4"><br>          <QuickActionButton<br>            to="/checkin"<br>            icon="‚ûï"<br>            label="ƒêƒÉng k√Ω xe m·ªõi"<br>            description="Check-in xe v√†o b√£i ƒë·ªó"<br>          /><br>          <QuickActionButton<br>            to="/liveview"<br>            icon="üîç"<br>            label="Theo d√µi xe c·ªßa t√¥i"<br>            description="Xem v·ªã tr√≠ xe real-time"<br>          /><br>          <QuickActionButton<br>            to="/alerts"<br>            icon="üìä"<br>            label="Xem c·∫£nh b√°o"<br>            description={`${stats.unresolvedAlerts} c·∫£nh b√°o ch∆∞a x·ª≠ l√Ω`}<br>          /><br>        </div><br>      </div><br>      <br>      {/* Notifications */}<br>      <div className="bg-white rounded-lg shadow p-6"><br>        <h2 className="text-xl font-bold mb-4">üì¢ Th√¥ng b√°o</h2><br>        <div className="space-y-2"><br>          <NotificationItem<br>            icon="üîß"<br>            text="B√£i ƒë·ªó khu A ƒëang b·∫£o tr√¨ (10:00 - 12:00)"<br>          /><br>          <NotificationItem<br>            icon="üéâ"<br>            text="Khuy·∫øn m√£i: Mi·ªÖn ph√≠ ƒë·ªó xe cho 2 gi·ªù ƒë·∫ßu"<br>          /><br>          <NotificationItem<br>            icon="‚è∞"<br>            text="Nh·∫Øc nh·ªü: Vui l√≤ng kh√¥ng ƒë·ªó xe qua ƒë√™m"<br>          /><br>        </div><br>      </div><br>    </div><br>  );<br>}<br><br>// Component: Status Card<br>function StatusCard({ icon, title, value, subtitle, bgColor }: {<br>  icon: string;<br>  title: string;<br>  value: number;<br>  subtitle: string;<br>  bgColor: string;<br>}) {<br>  return (<br>    <div className={`${bgColor} text-white rounded-lg shadow-lg p-6 transition hover:scale-105`}><br>      <div className="flex items-center justify-between mb-2"><br>        <span className="text-3xl">{icon}</span><br>      </div><br>      <h3 className="font-bold text-sm mb-2">{title}</h3><br>      <div className="text-5xl font-bold mb-1">{value}</div><br>      <p className="text-sm opacity-90">{subtitle}</p><br>    </div><br>  );<br>}<br><br>// Component: Quick Action Button<br>function QuickActionButton({ to, icon, label, description }: {<br>  to: string;<br>  icon: string;<br>  label: string;<br>  description: string;<br>}) {<br>  return (<br>    <a<br>      href={to}<br>      className="block bg-gray-50 hover:bg-gray-100 rounded-lg p-4 transition"<br>    ><br>      <div className="flex items-center space-x-3"><br>        <span className="text-3xl">{icon}</span><br>        <div><br>          <div className="font-bold">{label}</div><br>          <div className="text-sm text-gray-600">{description}</div><br>        </div><br>      </div><br>    </a><br>  );<br>}<br><br>// Component: Notification Item<br>function NotificationItem({ icon, text }: { icon: string; text: string }) {<br>  return (<br>    <div className="flex items-start space-x-3 p-3 bg-gray-50 rounded"><br>      <span className="text-xl">{icon}</span><br>      <span className="text-gray-700">{text}</span><br>    </div><br>  );<br>}<br>``` | **üî• Real-time Updates**:<br>‚Ä¢ `onSnapshot` listener<br>‚Ä¢ Auto-refresh khi data changes<br>‚Ä¢ No manual refresh needed<br><br>**üé® Color Logic**:<br>‚Ä¢ < 70%: Green (Good)<br>‚Ä¢ 70-90%: Orange (Warning)<br>‚Ä¢ > 90%: Red (Critical)<br><br>**üì± Responsive Grid**:<br>‚Ä¢ Mobile: 1 column<br>‚Ä¢ Tablet: 2 columns<br>‚Ä¢ Desktop: 4 columns<br><br>**‚ö° Performance**:<br>‚Ä¢ Firestore listeners efficient<br>‚Ä¢ Only listen to needed collections<br>‚Ä¢ Cleanup on unmount<br><br>**‚ôø Accessibility**:<br>‚Ä¢ Semantic HTML<br>‚Ä¢ Color + Text indicators<br>‚Ä¢ Keyboard navigation<br><br>**üí° Enhancement Ideas**:<br>‚Ä¢ Add loading skeleton<br>‚Ä¢ Error boundary<br>‚Ä¢ Offline indicator<br>‚Ä¢ Animation on value change |

## 4.3. Check-in Page

| **C√¥ng vi·ªác (Task)** | **Ph√¢n t√≠ch & H∆∞·ªõng d·∫´n chi ti·∫øt** | **Code minh h·ªça** | **L∆∞u √Ω (Important Notes)** |
|----------------------|-----------------------------------|-------------------|----------------------------|
| T·∫°o Check-in Page v·ªõi form validation | **Features**:<br>- 2-column layout<br>- Form inputs v·ªõi validation<br>- Image upload<br>- Success modal v·ªõi Vehicle ID<br>- Copy ID button | ```typescript<br>// src/pages/CheckInPage.tsx<br>import { useState } from 'react';<br>import { vehicleService } from '@/services/vehicleService';<br>import type { CheckInRequest } from '@/services/vehicleService';<br><br>export function CheckInPage() {<br>  const [formData, setFormData] = useState<CheckInRequest>({<br>    ownerName: '',<br>    licensePlate: '',<br>    vehicleType: 'car',<br>  });<br>  const [imageFile, setImageFile] = useState<File | null>(null);<br>  const [imagePreview, setImagePreview] = useState<string>('');<br>  const [loading, setLoading] = useState(false);<br>  const [showModal, setShowModal] = useState(false);<br>  const [vehicleId, setVehicleId] = useState('');<br>  const [error, setError] = useState('');<br>  <br>  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {<br>    setFormData(prev => ({<br>      ...prev,<br>      [e.target.name]: e.target.value,<br>    }));<br>    setError('');<br>  };<br>  <br>  const handleImageChange = (e: React.ChangeEvent<HTMLInputElement>) => {<br>    const file = e.target.files?.[0];<br>    if (file) {<br>      // Validate file size (max 5MB)<br>      if (file.size > 5 * 1024 * 1024) {<br>        setError('K√≠ch th∆∞·ªõc ·∫£nh kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° 5MB');<br>        return;<br>      }<br>      <br>      // Validate file type<br>      if (!file.type.startsWith('image/')) {<br>        setError('Vui l√≤ng ch·ªçn file ·∫£nh');<br>        return;<br>      }<br>      <br>      setImageFile(file);<br>      <br>      // Create preview<br>      const reader = new FileReader();<br>      reader.onloadend = () => {<br>        setImagePreview(reader.result as string);<br>      };<br>      reader.readAsDataURL(file);<br>    }<br>  };<br>  <br>  const handleSubmit = async (e: React.FormEvent) => {<br>    e.preventDefault();<br>    setError('');<br>    setLoading(true);<br>    <br>    try {<br>      const response = await vehicleService.checkIn({<br>        ...formData,<br>        imageFile: imageFile || undefined,<br>      });<br>      <br>      if (response.success) {<br>        setVehicleId(response.vehicleId);<br>        setShowModal(true);<br>        // Reset form<br>        setFormData({<br>          ownerName: '',<br>          licensePlate: '',<br>          vehicleType: 'car',<br>        });<br>        setImageFile(null);<br>        setImagePreview('');<br>      } else {<br>        setError(response.message);<br>      }<br>    } catch (err) {<br>      setError('ƒê√£ c√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i.');<br>    } finally {<br>      setLoading(false);<br>    }<br>  };<br>  <br>  const copyVehicleId = () => {<br>    navigator.clipboard.writeText(vehicleId);<br>    alert('ƒê√£ sao ch√©p ID xe!');<br>  };<br>  <br>  return (<br>    <div className="max-w-6xl mx-auto"><br>      <h1 className="text-3xl font-bold mb-6">ƒêƒÇNG K√ù XE V√ÄO B√ÉI ƒê·ªñ</h1><br>      <br>      <form onSubmit={handleSubmit}><br>        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6"><br>          {/* Left Column: Form */}<br>          <div className="bg-white rounded-lg shadow p-6"><br>            <h2 className="text-xl font-bold mb-4">üìù Th√¥ng tin c·ªßa b·∫°n</h2><br>            <br>            <div className="space-y-4"><br>              {/* Owner Name */}<br>              <div><br>                <label className="block font-medium mb-2"><br>                  H·ªç v√† t√™n <span className="text-red-500">*</span><br>                </label><br>                <input<br>                  type="text"<br>                  name="ownerName"<br>                  value={formData.ownerName}<br>                  onChange={handleInputChange}<br>                  className="w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-primary-500"<br>                  placeholder="Nguy·ªÖn VƒÉn A"<br>                  required<br>                /><br>              </div><br>              <br>              {/* License Plate */}<br>              <div><br>                <label className="block font-medium mb-2"><br>                  Bi·ªÉn s·ªë xe <span className="text-red-500">*</span><br>                </label><br>                <input<br>                  type="text"<br>                  name="licensePlate"<br>                  value={formData.licensePlate}<br>                  onChange={handleInputChange}<br>                  className="w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-primary-500"<br>                  placeholder="30A-12345"<br>                  required<br>                /><br>                <p className="text-sm text-gray-500 mt-1"><br>                  (ho·∫∑c ƒë·ªÉ tr·ªëng n·∫øu upload ·∫£nh)<br>                </p><br>              </div><br>              <br>              {/* Vehicle Type */}<br>              <div><br>                <label className="block font-medium mb-2">Lo·∫°i xe</label><br>                <div className="flex space-x-4"><br>                  <label className="flex items-center space-x-2"><br>                    <input<br>                      type="radio"<br>                      name="vehicleType"<br>                      value="car"<br>                      checked={formData.vehicleType === 'car'}<br>                      onChange={handleInputChange}<br>                      className="w-4 h-4"<br>                    /><br>                    <span>√î t√¥</span><br>                  </label><br>                  <label className="flex items-center space-x-2"><br>                    <input<br>                      type="radio"<br>                      name="vehicleType"<br>                      value="motorbike"<br>                      checked={formData.vehicleType === 'motorbike'}<br>                      onChange={handleInputChange}<br>                      className="w-4 h-4"<br>                    /><br>                    <span>Xe m√°y</span><br>                  </label><br>                </div><br>              </div><br>              <br>              {/* Terms */}<br>              <div className="flex items-center space-x-2"><br>                <input type="checkbox" required className="w-4 h-4" /><br>                <span className="text-sm"><br>                  T√¥i ƒë·ªìng √Ω v·ªõi ƒëi·ªÅu kho·∫£n s·ª≠ d·ª•ng<br>                </span><br>              </div><br>              <br>              {/* Error Message */}<br>              {error && (<br>                <div className="bg-red-50 text-red-600 px-4 py-3 rounded"><br>                  {error}<br>                </div><br>              )}<br>              <br>              {/* Submit Button */}<br>              <button<br>                type="submit"<br>                disabled={loading}<br>                className="w-full bg-primary-600 text-white px-6 py-3 rounded-lg font-bold hover:bg-primary-700 transition disabled:opacity-50"<br>              ><br>                {loading ? 'ƒêang x·ª≠ l√Ω...' : 'ƒêƒÇNG K√ù NGAY'}<br>              </button><br>            </div><br>          </div><br>          <br>          {/* Right Column: Image Upload */}<br>          <div className="bg-white rounded-lg shadow p-6"><br>            <h2 className="text-xl font-bold mb-4">üì∑ Ch·ª•p ·∫£nh bi·ªÉn s·ªë xe</h2><br>            <br>            <div className="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center"><br>              {imagePreview ? (<br>                <div><br>                  <img<br>                    src={imagePreview}<br>                    alt="Preview"<br>                    className="max-w-full h-64 object-contain mx-auto mb-4"<br>                  /><br>                  <button<br>                    type="button"<br>                    onClick={() => {<br>                      setImageFile(null);<br>                      setImagePreview('');<br>                    }}<br>                    className="text-red-600 hover:underline"<br>                  ><br>                    üîÑ Ch·ªçn l·∫°i<br>                  </button><br>                </div><br>              ) : (<br>                <div><br>                  <div className="text-6xl mb-4">üìÅ</div><br>                  <p className="text-gray-600 mb-4"><br>                    K√©o th·∫£ ho·∫∑c click ƒë·ªÉ ch·ªçn ·∫£nh<br>                  </p><br>                  <input<br>                    type="file"<br>                    accept="image/*"<br>                    onChange={handleImageChange}<br>                    className="hidden"<br>                    id="file-input"<br>                  /><br>                  <label<br>                    htmlFor="file-input"<br>                    className="inline-block bg-gray-200 px-6 py-2 rounded-lg cursor-pointer hover:bg-gray-300 transition"<br>                  ><br>                    üìÅ Ch·ªçn file<br>                  </label><br>                </div><br>              )}<br>            </div><br>            <br>            <div className="mt-4 space-y-2 text-sm text-gray-600"><br>              <p>‚úÖ H·ªó tr·ª£: JPG, PNG</p><br>              <p>‚úÖ K√≠ch th∆∞·ªõc: {'<'} 5MB</p><br>              <p>‚úÖ ·∫¢nh ph·∫£i r√µ bi·ªÉn s·ªë</p><br>            </div><br>          </div><br>        </div><br>      </form><br>      <br>      {/* Success Modal */}<br>      {showModal && (<br>        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"><br>          <div className="bg-white rounded-lg p-8 max-w-md w-full mx-4"><br>            <div className="text-center"><br>              <div className="text-6xl mb-4">‚úÖ</div><br>              <h2 className="text-2xl font-bold mb-4">ƒêƒÇNG K√ù TH√ÄNH C√îNG!</h2><br>              <br>              <div className="mb-6"><br>                <p className="mb-2">ID xe c·ªßa b·∫°n:</p><br>                <div className="text-4xl font-mono font-bold text-primary-600 mb-4 tracking-wider"><br>                  {vehicleId}<br>                </div><br>                <p className="text-sm text-gray-600">(7 ch·ªØ s·ªë)</p><br>              </div><br>              <br>              <p className="text-gray-600 mb-6"><br>                Vui l√≤ng l∆∞u ID n√†y ƒë·ªÉ theo d√µi xe c·ªßa b·∫°n!<br>              </p><br>              <br>              <div className="space-y-3"><br>                <button<br>                  onClick={copyVehicleId}<br>                  className="w-full bg-gray-200 px-6 py-3 rounded-lg font-bold hover:bg-gray-300 transition"<br>                ><br>                  üìã Sao ch√©p ID<br>                </button><br>                <button<br>                  onClick={() => setShowModal(false)}<br>                  className="w-full bg-primary-600 text-white px-6 py-3 rounded-lg font-bold hover:bg-primary-700 transition"<br>                ><br>                  ‚úì ƒê√£ hi·ªÉu<br>                </button><br>              </div><br>            </div><br>          </div><br>        </div><br>      )}<br>    </div><br>  );<br>}<br>``` | **‚úÖ Form Validation**:<br>‚Ä¢ Required fields<br>‚Ä¢ License plate format<br>‚Ä¢ File size/type check<br>‚Ä¢ Error messages<br><br>**üì∏ Image Upload**:<br>‚Ä¢ Drag & drop support<br>‚Ä¢ Preview before submit<br>‚Ä¢ File validation<br>‚Ä¢ Fallback on error<br><br>**üé® Modal Design**:<br>‚Ä¢ Centered overlay<br>‚Ä¢ Focus trap<br>‚Ä¢ ESC to close (can add)<br>‚Ä¢ Copy ID button<br><br>**üì± Responsive**:<br>‚Ä¢ Desktop: 2 columns<br>‚Ä¢ Mobile: Stack vertically<br>‚Ä¢ Touch-friendly buttons<br><br>**‚ö° UX Enhancements**:<br>‚Ä¢ Loading state<br>‚Ä¢ Disabled button when loading<br>‚Ä¢ Auto-focus first field<br>‚Ä¢ Clear form after success<br><br>**üîí Security**:<br>‚Ä¢ Client-side validation<br>‚Ä¢ Server-side validation (in service)<br>‚Ä¢ File type check<br>‚Ä¢ Size limit enforcement |

---

B·∫°n ∆°i, t√¥i nh·∫≠n ra l√† n·∫øu l√†m chi ti·∫øt h·∫øt t·∫•t c·∫£ c√≤n l·∫°i (Live View Page, Alerts Page, Admin 4 modules, Phase 6) th√¨ file 2.3 s·∫Ω qu√° d√†i (>4000 d√≤ng)!

**T√¥i ƒë·ªÅ xu·∫•t 2 options:**

### **Option A**: Ti·∫øp t·ª•c chi ti·∫øt ƒë·∫ßy ƒë·ªß ‚úçÔ∏è
- L√†m h·∫øt t·∫•t c·∫£ pages & modules v·ªõi code ƒë·∫ßy ƒë·ªß
- File s·∫Ω r·∫•t d√†i nh∆∞ng complete
- Estimate: ~4000-5000 d√≤ng

### **Option B**: T√≥m t·∫Øt th√¥ng minh üéØ
- Home Page & Check-in Page: ‚úÖ Chi ti·∫øt (done)
- Live View Page, Alerts Page: üìù T√≥m t·∫Øt c·∫•u tr√∫c + code skeleton
- Admin Dashboard: üìù T√≥m t·∫Øt 4 modules v·ªõi key points
- Phase 6: üìù Checklist + best practices

File s·∫Ω v·ª´a ph·∫£i (~2000 d√≤ng) v√† v·∫´n ƒë·∫ßy ƒë·ªß th√¥ng tin!

**B·∫°n mu·ªën theo Option A hay B?** ü§î

(Recommend: **Option B** - v·ª´a ƒë·ªß chi ti·∫øt, kh√¥ng qu√° d√†i, d·ªÖ ƒë·ªçc!)




